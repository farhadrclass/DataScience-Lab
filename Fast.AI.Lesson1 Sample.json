{"paragraphs":[{"text":"%md\n\n# Using the GPU #\n\nFor an introductory discussion of Graphical Processing Units (GPU) and their use for intensive parallel computation purposes, see [GPGPU](http://en.wikipedia.org/wiki/GPGPU).\n\nOne of Theano’s design goals is to specify computations at an abstract level, so that the internal function compiler has a lot of flexibility about how to carry out those computations. One of the ways we take advantage of this flexibility is in carrying out calculations on a graphics card.\n\nUsing the GPU in Theano is as simple as setting the device configuration flag to device=cuda. You can optionally target a specific gpu by specifying the number of the gpu as in e.g. device=cuda2. It is also encouraged to set the floating point precision to float32 when working on the GPU as that is usually much faster. For example: **THEANO_FLAGS='device=cuda,floatX=float32'**. You can also set these options in the **.theanorc** file’s [global] section:\n\n    [global]\n    device = cuda\n    floatX = float32\n\nCheck theano config with\n    *python3 -c 'import theano; print(theano.config)' | less*\n    \n<http://deeplearning.net/software/theano/tutorial/using_gpu.html>\n","user":"admin","dateUpdated":"2018-02-09T15:35:52-0500","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","editorHide":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Using the GPU</h1>\n<p>For an introductory discussion of Graphical Processing Units (GPU) and their use for intensive parallel computation purposes, see <a href=\"http://en.wikipedia.org/wiki/GPGPU\">GPGPU</a>.</p>\n<p>One of Theano’s design goals is to specify computations at an abstract level, so that the internal function compiler has a lot of flexibility about how to carry out those computations. One of the ways we take advantage of this flexibility is in carrying out calculations on a graphics card.</p>\n<p>Using the GPU in Theano is as simple as setting the device configuration flag to device=cuda. You can optionally target a specific gpu by specifying the number of the gpu as in e.g. device=cuda2. It is also encouraged to set the floating point precision to float32 when working on the GPU as that is usually much faster. For example: <strong>THEANO_FLAGS=&lsquo;device=cuda,floatX=float32&rsquo;</strong>. You can also set these options in the <strong>.theanorc</strong> file’s [global] section:</p>\n<pre><code>[global]\ndevice = cuda\nfloatX = float32\n</code></pre>\n<p>Check theano config with<br/> <em>python3 -c &lsquo;import theano; print(theano.config)&rsquo; | less</em></p>\n<p><a href=\"http://deeplearning.net/software/theano/tutorial/using_gpu.html\">http://deeplearning.net/software/theano/tutorial/using_gpu.html</a></p>\n</div>"}]},"apps":[],"jobName":"paragraph_1517431134229_-1623995954","id":"20180131-153854_449415491","dateCreated":"2018-01-31T15:38:54-0500","dateStarted":"2018-02-09T15:35:52-0500","dateFinished":"2018-02-09T15:35:52-0500","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:204"},{"text":"%spark.pyspark\n\nfrom theano import function, config, shared, tensor\nimport numpy\nimport time\n\nvlen = 10 * 30 * 768  # 10 x #cores x # threads per core\niters = 1000\n\nrng = numpy.random.RandomState(22)\nx = shared(numpy.asarray(rng.rand(vlen), config.floatX))\nf = function([], tensor.exp(x))\nprint(f.maker.fgraph.toposort())\nt0 = time.time()\nfor i in range(iters):\n    r = f()\nt1 = time.time()\nprint(\"Looping %d times took %f seconds\" % (iters, t1 - t0))\nprint(\"Result is %s\" % (r,))\nif numpy.any([isinstance(x.op, tensor.Elemwise) and\n              ('Gpu' not in type(x.op).__name__)\n              for x in f.maker.fgraph.toposort()]):\n    print('Used the cpu')\nelse:\n    print('Used the gpu')\n","user":"admin","dateUpdated":"2018-02-09T15:36:04-0500","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517431253666_-1321382460","id":"20180131-154053_1474256534","dateCreated":"2018-01-31T15:40:53-0500","dateStarted":"2018-02-09T15:36:04-0500","dateFinished":"2018-02-09T15:56:23-0500","status":"ABORT","progressUpdateIntervalMs":500,"$$hashKey":"object:205"},{"text":"%md\n#\nUsing Convolutional Neural Networks\n===\nWelcome to the first week of the first deep learning certificate! We're going to use convolutional neural networks (CNNs) to allow our computer to see - something that is only possible thanks to deep learning.\nIntroduction to this week's task: 'Dogs vs Cats'\n---\nWe're going to try to create a model to enter the Dogs vs Cats competition at Kaggle. There are 25,000 labelled dog and cat photos available for training, and 12,500 in the test set that we have to try to label for this competition. According to the Kaggle web-site, when this competition was launched (end of 2013): ***\"State of the art:*** *The current literature suggests machine classifiers can score above 80% accuracy on this task\"*. So if we can beat 80%, then we will be at the cutting edge as of 2013!\nBasic setup\n---\nThere isn't too much to do to get started - just a few simple configuration steps.\nThis shows plots in the web page itself - we always wants to use this when using jupyter notebook:","user":"admin","dateUpdated":"2018-01-31T12:39:27-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648562_1248543719","id":"20171128-120956_1062305650","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:39:27-0500","dateFinished":"2018-01-31T12:39:32-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:206"},{"text":"%spark.pyspark\n\nimport matplotlib\n#%matplotlib inline\n\nimport sys \nprint(sys.version)\n","user":"admin","dateUpdated":"2018-02-01T16:10:02-0500","config":{"tableHide":false,"editorSetting":{"language":"python","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/python","editorHide":false,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648565_1245850477","id":"20171128-121102_1396296943","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-02-01T16:10:02-0500","dateFinished":"2018-02-01T16:10:02-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:207"},{"text":"%spark.pyspark\n\n#\n# Define path to data: (It's a good idea to put it in a subdirectory of your notebooks folder, and then exclude that directory from git control by adding it to .gitignore.)\n#\npath = \"/usr/local/share/dsLab/datasets/dogscats/\"\n\n#\n# A few basic libraries that we'll need for the initial exercises:\n#\nfrom __future__ import division,print_function\n\nimport os, json, sys\nfrom glob import glob\nimport numpy as np\nnp.set_printoptions(precision=4, linewidth=100)\nfrom matplotlib import pyplot as plt\n\n# the FastAI test dir contains the desired util\nsys.path.append('/usr/local/share/dsLab/courses-master/python34/')\nsys.path.append('/usr/local/share/dsLab/courses-master/python34/utils.py')\nprint (sys.path)\n#sys.path.append('/usr/local/zeppelin/pyUtils')\n\n# We have created a file most imaginatively called 'utils.py' to store any little convenience functions we'll want to use. We will discuss these as we use them.\nfrom imp import reload\nimport utils; reload(utils)\nfrom utils import plots","user":"admin","dateUpdated":"2018-02-01T16:10:05-0500","config":{"tableHide":false,"editorSetting":{"language":"python","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648567_1246619975","id":"20171128-122508_123499265","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-02-01T16:10:06-0500","dateFinished":"2018-02-01T16:10:13-0500","status":"ERROR","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:208"},{"text":"%md\n# Use a pretrained VGG model with our Vgg16 class #\nOur first step is simply to use a model that has been fully created for us, which can recognise a wide variety (1,000 categories) of images. We will use 'VGG', which won the 2014 Imagenet competition, and is a very simple model to create and understand. The VGG Imagenet team created both a larger, slower, slightly more accurate model (VGG 19) and a smaller, faster model (VGG 16). We will be using VGG 16 since the much slower performance of VGG19 is generally not worth the very minor improvement in accuracy.\nWe have created a python class, Vgg16, which makes using the VGG 16 model very straightforward.\n## The punchline: state of the art custom model in 7 lines of code ##\nHere's everything you need to do to get >97% accuracy on the Dogs vs Cats dataset - we won't analyze how it works behind the scenes yet, since at this stage we're just going to focus on the minimum necessary to actually do useful work.","user":"admin","dateUpdated":"2018-01-31T12:42:21-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648568_1244696230","id":"20171128-122810_758950642","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:42:21-0500","dateFinished":"2018-01-31T12:42:21-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:209"},{"text":"%spark.pyspark\r\n\r\n# As large as you can, but no larger than 64 is recommended. \r\n# If you have an older or cheaper GPU, you'll run out of memory, so will have to decrease this.\r\n#batch_size=64\r\nbatch_size=32","user":"admin","dateUpdated":"2018-02-01T16:10:58-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648569_1244311481","id":"20171128-122828_76714447","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-02-01T16:10:59-0500","dateFinished":"2018-02-01T16:10:59-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:210"},{"text":"%spark.pyspark\n\n# Import our class, and instantiate\nfrom imp import reload\nimport vgg16; reload(vgg16)\nfrom vgg16 import Vgg16","user":"admin","dateUpdated":"2018-02-01T16:11:01-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648570_1245465728","id":"20171128-123939_1489699946","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-02-01T16:11:02-0500","dateFinished":"2018-02-01T16:11:11-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:211"},{"text":"%spark.pyspark\n\npath = \"/usr/local/share/dsLab/dogscats/sample/\"\n#path = \"/usr/local/share/dsLab/dogscats/\"\n\nvgg = Vgg16()\n# Grab a few images at a time for training and validation.\n# NB: They must be in subdirectories named based on their category\nbatches = vgg.get_batches(path+'train', batch_size=batch_size)\nval_batches = vgg.get_batches(path+'valid', batch_size=batch_size*2)\nvgg.finetune(batches)\nvgg.fit(batches, val_batches, nb_epoch=1)\n","user":"admin","dateUpdated":"2018-02-01T16:11:13-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648570_1245465728","id":"20171128-123953_1337887177","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-02-01T16:11:13-0500","dateFinished":"2018-02-01T16:13:25-0500","status":"ERROR","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:212"},{"text":"%md\nThe code above will work for any image recognition task, with any number of categories! All you have to do is to put your images into one folder per category, and run the code above.\nLet's take a look at how this works, step by step...\n# Use Vgg16 for basic image recognition #\nLet's start off by using the Vgg16 class to recognise the main imagenet category for each image.\nWe won't be able to enter the Cats vs Dogs competition with an Imagenet model alone, since 'cat' and 'dog' are not categories in Imagenet - instead each individual breed is a separate category. However, we can use it to see how well it can recognise the images, which is a good first step.\n","user":"admin","dateUpdated":"2018-01-31T12:53:19-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648571_1245080979","id":"20171128-124042_1551890333","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:53:19-0500","dateFinished":"2018-01-31T12:53:19-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:213"},{"text":"%spark.pyspark\n\n# First, create a Vgg16 object:\n#vgg = Vgg16()\n\n# Vgg16 is built on top of Keras (which we will be learning much more about shortly!), a flexible, easy to use deep learning library that sits on top of Theano or Tensorflow. \n# Keras reads groups of images and labels in batches, using a fixed directory structure, where images from each category for training must be placed in a separate folder.\n# Let's grab batches of data from our training folder:\n#batches = vgg.get_batches(path+'train', batch_size=batch_size)\n\n# (BTW, when Keras refers to 'classes', it doesn't mean python classes - but rather it refers to the categories of the labels, such as 'pug', or 'tabby'.)\n# Batches is just a regular python iterator. Each iteration returns both the images themselves, as well as the labels.\nimgs,labels = next(batches)\n\n# As you can see, the labels for each image are an array, containing a 1 in the first position if it's a cat, and in the second position if it's a dog. \n# This approach to encoding categorical variables, where an array containing just a single 1 in the position corresponding to the category, is very common in deep learning. \n# It is called one hot encoding.\n# The arrays contain two elements, because we have two categories (cat, and dog). If we had three categories (e.g. cats, dogs, and kangaroos), then the arrays would each contain two 0's, and one 1.\nplots(imgs, titles=labels)\n","user":"admin","dateUpdated":"2018-01-31T12:53:30-0500","config":{"editorSetting":{"language":"python","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/python","editorHide":false,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648571_1245080979","id":"20171129-132336_280804241","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:53:33-0500","dateFinished":"2018-01-31T12:54:00-0500","status":"ERROR","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:214"},{"text":"%spark.pyspark\n\n# We can now pass the images to Vgg16's predict() function to get back probabilities, category indexes, and category names for each image's VGG prediction.\nvgg.predict(imgs, True)\n","user":"admin","dateUpdated":"2018-01-31T12:53:48-0500","config":{"tableHide":false,"editorSetting":{"language":"python","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/python","editorHide":false,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648575_1243541984","id":"20171129-143959_1499134072","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:53:49-0500","dateFinished":"2018-01-31T12:57:46-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:215"},{"text":"%spark.pyspark\n\n\n# The category indexes are based on the ordering of categories used in the VGG model - e.g here are the first four:\nvgg.classes[:4]","user":"admin","dateUpdated":"2018-01-31T12:53:56-0500","config":{"tableHide":false,"editorSetting":{"language":"python","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/python","editorHide":false,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648576_1229306274","id":"20171129-144028_201424682","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:54:00-0500","dateFinished":"2018-01-31T12:57:46-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:216"},{"text":"%md\n(Note that, other than creating the Vgg16 object, none of these steps are necessary to build a model; they are just showing how to use the class to view imagenet predictions.)\n# Use our Vgg16 class to finetune a Dogs vs Cats model #\nTo change our model so that it outputs \"cat\" vs \"dog\", instead of one of 1,000 very specific categories, we need to use a process called \"finetuning\". Finetuning looks from the outside to be identical to normal machine learning training - we provide a training set with data and labels to learn from, and a validation set to test against. The model learns a set of parameters based on the data provided.\nHowever, the difference is that we start with a model that is already trained to solve a similar problem. The idea is that many of the parameters should be very similar, or the same, between the existing model, and the model we wish to create. Therefore, we only select a subset of parameters to train, and leave the rest untouched. This happens automatically when we call fit() after calling finetune().\nWe create our batches just like before, and making the validation set available as well. A 'batch' (or mini-batch as it is commonly known) is simply a subset of the training data - we use a subset at a time when training or predicting, in order to speed up training, and to avoid running out of memory.\n","user":"admin","dateUpdated":"2018-01-31T12:59:55-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648576_1229306274","id":"20171129-132711_1970168646","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T12:59:55-0500","dateFinished":"2018-01-31T12:59:55-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:217"},{"text":"%md\n","user":"admin","dateUpdated":"2018-01-31T15:38:33-0500","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517431111874_-1957973323","id":"20180131-153831_1772551668","dateCreated":"2018-01-31T15:38:31-0500","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:218"},{"text":"%spark.pyspark\nbatch_size=32\n\nbatches = vgg.get_batches(path+'train', batch_size=batch_size)\nval_batches = vgg.get_batches(path+'valid', batch_size=batch_size)\n\n# Calling finetune() modifies the model such that it will be trained based on the data in the batches provided - in this case, to predict either 'dog' or 'cat'.\nvgg.finetune(batches)\n\n# Finally, we fit() the parameters of the model using the training data, reporting the accuracy on the validation set after every epoch. (An epoch is one full pass through the training data.)\nvgg.fit(batches, val_batches, nb_epoch=1)\n\n\n","user":"admin","dateUpdated":"2018-01-31T15:30:26-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648576_1229306274","id":"20171129-132837_917230884","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T15:30:36-0500","dateFinished":"2018-01-31T15:35:41-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:219"},{"text":"%md\nThat shows all of the steps involved in using the Vgg16 class to create an image recognition model using whatever labels you are interested in. For instance, this process could classify paintings by style, or leaves by type of disease, or satellite photos by type of crop, and so forth.\nNext up, we'll dig one level deeper to see what's going on in the Vgg16 class.\n# Create a VGG model from scratch in Keras #\nFor the rest of this tutorial, we will not be using the Vgg16 class at all. Instead, we will recreate from scratch the functionality we just used. This is not necessary if all you want to do is use the existing model - but if you want to create your own models, you'll need to understand these details. It will also help you in the future when you debug any problems with your models, since you'll understand what's going on behind the scenes.\n## Model setup ##\nWe need to import all the modules we'll be using from numpy, scipy, and keras:\n","user":"admin","dateUpdated":"2018-01-31T11:07:55-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648577_1228921525","id":"20171129-134255_1514476932","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:07:56-0500","dateFinished":"2018-01-31T11:07:56-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:220"},{"text":"%spark.pyspark\n\nfrom numpy.random import random, permutation\nfrom scipy import misc, ndimage\nfrom scipy.ndimage.interpolation import zoom\n\nimport keras\nfrom keras import backend as K\nfrom keras.utils.data_utils import get_file\nfrom keras.models import Sequential, Model\nfrom keras.layers.core import Flatten, Dense, Dropout, Lambda\nfrom keras.layers import Input\nfrom keras.layers.convolutional import Convolution2D, MaxPooling2D, ZeroPadding2D\nfrom keras.optimizers import SGD, RMSprop\nfrom keras.preprocessing import image\n","user":"admin","dateUpdated":"2018-01-31T11:09:31-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648577_1228921525","id":"20171129-134320_1562995743","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:09:31-0500","dateFinished":"2018-01-31T11:09:31-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:221"},{"text":"%spark.pyspark\n\n# Let's import the mappings from VGG ids to imagenet category ids and descriptions, for display purposes later.\nFILES_PATH = 'http://files.fast.ai/models/'; CLASS_FILE='imagenet_class_index.json'\n# Keras' get_file() is a handy function that downloads files, and caches them for re-use later\nfpath = get_file(CLASS_FILE, FILES_PATH+CLASS_FILE, cache_subdir='models')\nwith open(fpath) as f: class_dict = json.load(f)\n# Convert dictionary with string indexes into an array\nclasses = [class_dict[str(i)][1] for i in range(len(class_dict))]\n","user":"admin","dateUpdated":"2018-01-31T11:09:45-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648578_1230075772","id":"20171129-134342_1469991959","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:09:45-0500","dateFinished":"2018-01-31T11:09:45-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:222"},{"text":"%spark.pyspark\n\n# Here's a few examples of the categories we just imported:\nclasses[:5]\n","user":"admin","dateUpdated":"2018-01-31T11:16:52-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648578_1230075772","id":"20171129-134407_1251665330","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:16:52-0500","dateFinished":"2018-01-31T11:16:55-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:223"},{"text":"%md\n## Model creation ##\nCreating the model involves creating the model architecture, and then loading the model weights into that architecture. We will start by defining the basic pieces of the VGG architecture.\nVGG has just one type of convolutional block, and one type of fully connected ('dense') block. Here's the convolutional block definition:\n","user":"admin","dateUpdated":"2018-01-31T11:10:12-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648579_1229691023","id":"20171129-134446_1553259375","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:10:12-0500","dateFinished":"2018-01-31T11:10:12-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:224"},{"text":"%spark.pyspark\n\ndef ConvBlock(layers, model, filters):\n    for i in range(layers): \n        model.add(ZeroPadding2D((1,1)))\n        model.add(Convolution2D(filters, 3, 3, activation='relu'))\n    model.add(MaxPooling2D((2,2), strides=(2,2)))\n\n# ...and here's the fully-connected definition.\ndef FCBlock(model):\n    model.add(Dense(4096, activation='relu'))\n    model.add(Dropout(0.5))\n\n# When the VGG model was trained in 2014, the creators subtracted the average of each of the three (R,G,B) channels first, so that the data for each channel had a mean of zero. \n# Furthermore, their software that expected the channels to be in B,G,R order, whereas Python by default uses R,G,B. \n# We need to preprocess our data to make these two changes, so that it is compatible with the VGG model:\n\n# Mean of each channel as provided by VGG researchers\nvgg_mean = np.array([123.68, 116.779, 103.939]).reshape((3,1,1))\n\ndef vgg_preprocess(x):\n    x = x - vgg_mean     # subtract mean\n    return x[:, ::-1]    # reverse axis bgr->rgb\n    \n# Now we're ready to define the VGG model architecture - look at how simple it is, now that we have the basic blocks defined!\ndef VGG_16():\n    model = Sequential()\n    model.add(Lambda(vgg_preprocess, input_shape=(3,224,224)))\n\n    ConvBlock(2, model, 64)\n    ConvBlock(2, model, 128)\n    ConvBlock(3, model, 256)\n    ConvBlock(3, model, 512)\n    ConvBlock(3, model, 512)\n\n    model.add(Flatten())\n    FCBlock(model)\n    FCBlock(model)\n    model.add(Dense(1000, activation='softmax'))\n    return model\n","user":"admin","dateUpdated":"2018-01-31T11:17:13-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648579_1229691023","id":"20171129-134432_2032047100","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:17:13-0500","dateFinished":"2018-01-31T11:17:13-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:225"},{"text":"%md\nWe'll learn about what these different blocks do later in the course. For now, it's enough to know that:\n* Convolution layers are for finding patterns in images\n* Dense (fully connected) layers are for combining patterns across an image\nNow that we've defined the architecture, we can create the model like any python object:\n","user":"admin","dateUpdated":"2018-01-31T11:17:27-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648580_1227767279","id":"20171129-134635_792478465","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:17:27-0500","dateFinished":"2018-01-31T11:17:27-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:226"},{"text":"%spark.pyspark\nmodel = VGG_16()\n\n# As well as the architecture, we need the weights that the VGG creators trained. \n# The weights are the part of the model that is learnt from the data, whereas the architecture is pre-defined based on the nature of the problem.\n\n# Downloading pre-trained weights is much preferred to training the model ourselves, since otherwise we would have to download the entire Imagenet archive, and train the model for many days! \n# It's very helpful when researchers release their weights, as they did here.\nfpath = get_file('vgg16.h5', FILES_PATH+'vgg16.h5', cache_subdir='models')\nmodel.load_weights(fpath)","user":"admin","dateUpdated":"2018-01-31T11:17:43-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648580_1227767279","id":"20171129-134659_1876526966","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:17:44-0500","dateFinished":"2018-01-31T11:21:15-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:227"},{"text":"%md\n# Getting imagenet predictions #\nThe setup of the imagenet model is now complete, so all we have to do is grab a batch of images and call predict() on them.\n","user":"admin","dateUpdated":"2018-01-31T11:18:14-0500","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648581_1227382530","id":"20171129-143323_1259850240","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:18:14-0500","dateFinished":"2018-01-31T11:18:15-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:228"},{"text":"%spark.pyspark\n\nbatch_size = 32\n\n# Keras provides functionality to create batches of data from directories containing images; \n# all we have to do is to define the size to resize the images to, what type of labels to create, whether to randomly shuffle the images,\n# and how many images to include in each batch. We use this little wrapper to define some helpful defaults appropriate for imagenet data:\ndef get_batches(dirname, gen=image.ImageDataGenerator(), shuffle=True, \n                batch_size=batch_size, class_mode='categorical'):\n    return gen.flow_from_directory(path+dirname, target_size=(224,224), \n                class_mode=class_mode, shuffle=shuffle, batch_size=batch_size)\n                \n# From here we can use exactly the same steps as before to look at predictions from the model.\nbatches = get_batches('train', batch_size=batch_size)\nval_batches = get_batches('valid', batch_size=batch_size)\nimgs,labels = next(batches)\n\n# This shows the 'ground truth'\nplots(imgs, titles=labels)\n\n\n","dateUpdated":"2018-01-31T11:18:44-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648581_1227382530","id":"20171129-144732_192804004","dateCreated":"2018-01-29T14:54:08-0500","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:229"},{"text":"%spark.pyspark\n\n# The VGG model returns 1,000 probabilities for each image, representing the probability that the model assigns to each possible imagenet category for each image. \n# By finding the index with the largest probability (with np.argmax()) we can find the predicted label.\n\ndef pred_batch(imgs):\n    preds = model.predict(imgs)\n    idxs = np.argmax(preds, axis=1)\n\n    print('Shape: {}'.format(preds.shape))\n    print('First 5 classes: {}'.format(classes[:5]))\n    print('First 5 probabilities: {}\\n'.format(preds[0, :5]))\n    print('Predictions prob/class: ')\n    \n    for i in range(len(idxs)):\n        idx = idxs[i]\n        print ('  {:.4f}/{}'.format(preds[i, idx], classes[idx]))\n","user":"admin","dateUpdated":"2018-01-31T11:25:31-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648584_1226228283","id":"20171129-144911_1894723502","dateCreated":"2018-01-29T14:54:08-0500","dateStarted":"2018-01-31T11:25:32-0500","dateFinished":"2018-01-31T11:25:34-0500","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:230"},{"text":"%spark.pyspark\n\npred_batch(imgs)","user":"admin","dateUpdated":"2018-01-31T11:25:42-0500","config":{"colWidth":12,"editorMode":"ace/mode/python","results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648584_1226228283","id":"20171129-145112_413436236","dateCreated":"2018-01-29T14:54:08-0500","status":"ABORT","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:231"},{"text":"%python\n","dateUpdated":"2018-01-29T14:54:08-0500","config":{"colWidth":12,"editorMode":"ace/mode/text","results":{},"enabled":true,"editorSetting":{"language":"text","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1517255648584_1226228283","id":"20171129-145125_90749363","dateCreated":"2018-01-29T14:54:08-0500","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:232"}],"name":"Fast.AI.Lesson1 Sample","id":"2D5R18KVK","angularObjects":{"2CKX8WPU1:shared_process":[],"2CKAY1A8Y:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}